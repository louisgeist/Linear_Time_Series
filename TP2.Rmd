---
title: "R Notebook"
output: html_notebook
---

# TP2 de de séries temporelles linéaires

```{r}
rm(list = ls())
library(zoo) #format de serie temporelle pratique et facile d'utilisation (mais plus volumineux)
library("ggplot2")
library("tseries")
```

### Question 1 - importation des données

```{r}
source = read.csv(file = "./Donnees/Donnees_TP2.csv", sep =";")
```

### Question 2 - première représentation graphique

```{r}
index = c(1:254)
source = as.data.frame(cbind(source,index)) # La correction fait une chose équivalente de manière plus élégante.


p_spread = ggplot(data = source) + geom_line(aes(x = source$index,y=source$spread))
p_spread


```

Cela évoque une marche aléatoire.

```{r}
dspread = diff(source$spread)
index = 2:254

df_diff = cbind.data.frame(index,dspread)
ggplot(data=df_diff)+geom_line(aes(x=index,y=dspread))
```

La série brute semble être persistante et avoir une tendance linéaire, voire non déterministe : elle évoque une marché aléatoire.

Cependant, sa transformation *first difference* a évoque une série stationnaire. Cela ressemble à un bruit blanc, aussi peut-être un ARMA ou autre chose..

Ainsi, la série du spread est probablement $I(1)$.

### Question 3

```{r}
summary(lm(source$spread ~ source$index))
```

Le coefficient de index est bien négatif et peut-être statistiquement significatif *(on ne peut pas vraiment le confirmer, car le test n'est pas valide en présence de résidus autocorrélés)*. Donc on va être dans le cas des tests de racine unitaire avec constante et tendance non nulles.

D'où le test de Dicket-Fuller qui va être utilisé (et non Philipps-Perron comme dans le TP1).

```{r}
#library("fUnitRoots")

Qtests <- function(series, k, fitdf=0) {
  pvals <- apply(matrix(1:k), 1, FUN=function(l) {
    pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
    return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}

adf <- fUnitRoots::adfTest(source$spread, lag=0, type="ct") #
# adf

Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
```

Il faut changer les paramètres du modèle, pcq les résidus sont autocorrélés au seuil de 5% jusqu'à un lag de 13. Le test ADF n'est valide que s'il y a absence d'autocorrélations des résidus. On ne peut donc pas encore interpréter le résultat du test ADF.

Déterminons le nombre de retard de $\Delta X_t$ nécessaires pour que les résidus ne soient plus autocorrélés.

```{r}
library(fUnitRoots)
series <- source$spread; kmax <- 24; adftype="ct"

adfTest_valid <- function(series, kmax, adftype){
  k <- 0
  noautocorr <- 0
  while (noautocorr==0){
    cat(paste0("ADF with ",k," lags: residuals OK? "))
    adf <- adfTest(series, lags=k, type=adftype)
    pvals <- Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))[,2]
    if (sum(pvals<0.05,na.rm=T)==0) {
      noautocorr <- 1; cat("OK \n")
    } else cat("No \n")
    k <- k+1
  }
  return(adf)
}
adf <- adfTest_valid(series,24,adftype="ct")
#
Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
#
adf
#
summary(lm(dspread ~ source$dates[-1]))
#
adf <- adfTest_valid(dspread,24,"nc")
#
Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
adf
```

Les tests réalisés indiquent qu'on a besoin de 13 retards pour supprimer l'autocorrélation des résidus.

On effectue donc le test ADF avec 13 retards.

```{r}
fUnitRoots::adfTest(source$spread,lag = 13, type="ct")
```

L'hypothèse de racine unitaire n'est pas rejetée au seul de $5\%$ pour la série en niveau, la série est donc au moins $I(1)$.

On travaille donc maintenant sur la série différenciée.
